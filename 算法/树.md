### 94 输出中序遍历

给定一个二叉树的根节点 root ，返回它的 中序 遍历。

https://leetcode-cn.com/problems/binary-tree-inorder-traversal

```javascript
/* 
	递归 
	使用闭包避免arr的函数污染 而且能进行递归
*/
 var inorderTraversal = function(root) {
    let arr = [];
    const f = (root) => {
        if(root === null)
            return ;
        f(root.left);
        arr.push(root.val);
        f(root.right);   
    }
    f(root);
    return arr;
};

/* 迭代 */
var inorderTraversal = function(root) {
    const res = [];
    const stk = [];
    while (root || stk.length) {
        while (root) {
            stk.push(root);
            root = root.left;
        }
        root = stk.pop();
        res.push(root.val);
        root = root.right;
    }
    return res;
};
```

### 105 从前中序遍历构造二叉树

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal

```javascript
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
 var buildTree = function(preorder, inorder) {
    let arr = new Map();
    for(let i = 0; i < inorder.length; i++)
        arr.set(inorder[i],i);
    const f = function (preorder,inorder,pl,pr,il,ir) {  
        if(pl > pr)
            return null;
        /* 找到根节点 */
        let m = arr.get(preorder[pl]);
        /* 获得在中序中 根节点左子树的中序遍历个数 */
        let l = m - il;
        const root = new TreeNode(preorder[pl]);
        root.left = f(preorder,inorder,pl + 1,pl + l,il,m - 1);
        root.right = f(preorder,inorder,pl + m + 1,pr,m + 1,ir);
        return root;
    }
    return f(preorder,inorder,0,preorder.length - 1,0,inorder.length - 1);
};
```

### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

------

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

https://leetcode-cn.com/problems/validate-binary-search-tree
思路：基于二叉树的特点 （设置最大小值 每次遇到根节点修改相对于的最大最小值

```javascript
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function (root) {
  const f = function (root, low, heig) {
    if (root == null) return true
    if (root.val <= low || root.val >= heig) return false
    return f(root.left, low, root.val) && f(root.right, root.val, heig)
  }
  return f(root, -Infinity, Infinity)
}

var isValidBST = function(root) {
    let stack = [];
    let inorder = -Infinity;

    while (stack.length || root !== null) {
        while (root !== null) {
            stack.push(root);
            root = root.left;
        }
        root = stack.pop();
        // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
        if (root.val <= inorder) {
            return false;
        }
        inorder = root.val;
        root = root.right;
    }
    return true;
};
```

### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

```javascript
var isSymmetric = function (root) {
  const f = function (l, r) {
    if (l == null && r == null) return true
    if (l == null || r == null) return false
    return l.val == r.val && f(l.left, r.right) && f(l.right, r.left)
  }
  return f(root)
}
```

### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

思路：BFS 广度搜索 使用队列

```javascript
var levelOrder = function (root) {
  const arr = []
  const stk = []
  if (!root) return arr
  stk.push(root)
  while (stk.length != 0) {
    arr.push([])
    let n = stk.length
    for (let i = 0; i < n; i++) {
      let node = stk.shift()
      arr[arr.length - 1].push(node.val)
      if (node.left) stk.push(node.left)
      if (node.right) stk.push(node.right)
    }
  }
  return arr
}
```

### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

 思路：递归不好 在某次中退出 因此采用迭代

```javascript
var kthSmallest = function(root, k) {
    const stack = [];
    while (root != null || stack.length) {
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
        root = stack.pop();
        --k;
        if (k === 0) {
            break;
        }
        root = root.right;
    }
    return root.val;
};
```

### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

思路：

​	两种情况：处在左右子树 || 本身值已经符合 + 子树存在该值

```javascript
var lowestCommonAncestor = function(root, p, q) {
    let ans;
    /* dfs： 判断在root的左右子树是否存在p/q */
    const dfs = (root, p, q) => {
        if (root === null) return false;
        /* 不断遍历左右节点 */
        const lson = dfs(root.left, p, q);
        const rson = dfs(root.right, p, q);
        /* p/q处在root左右子树 || p/q已经符合 + 子树存在其他值 */
        if ((lson && rson) || ((root.val === p.val || root.val === q.val) && (lson || rson))) {
            ans = root;
        } 
        /* 返回左右节点是否存在p/q */
        return lson || rson || (root.val === p.val || root.val === q.val);
    }
    dfs(root, p, q);
    return ans;
};
```

### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42

```javascript
var maxPathSum = function (root) {
  let ans = -Infinity
  /* dfs:获得root为根的最大值 */
  const dfs = root => {
    if (root == null) return 0
    /* 获得左右子树的最大值 */
    const l = Math.max(dfs(root.left), 0)
    const r = Math.max(dfs(root.right), 0)
    /* 动态修改ans最大值 即每一次不一定从根借节点开始走 */
    let max = root.val + l + r
    ans = Math.max(max, ans)
    return root.val + Math.max(l, r)
  }
  return ans
}
```

