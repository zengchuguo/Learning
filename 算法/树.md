### 94 输出中序遍历

给定一个二叉树的根节点 root ，返回它的 中序 遍历。

https://leetcode-cn.com/problems/binary-tree-inorder-traversal

```javascript
/* 
	递归 
	使用闭包避免arr的函数污染 而且能进行递归
*/
 var inorderTraversal = function(root) {
    let arr = [];
    const f = (root) => {
        if(root === null)
            return ;
        f(root.left);
        arr.push(root.val);
        f(root.right);   
    }
    f(root);
    return arr;
};

/* 迭代 */
var inorderTraversal = function(root) {
    const res = [];
    const stk = [];
    while (root || stk.length) {
        while (root) {
            stk.push(root);
            root = root.left;
        }
        root = stk.pop();
        res.push(root.val);
        root = root.right;
    }
    return res;
};
```

### 105 从前中序遍历构造二叉树

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal

```javascript
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
 var buildTree = function(preorder, inorder) {
    let arr = new Map();
    for(let i = 0; i < inorder.length; i++)
        arr.set(inorder[i],i);
    const f = function (preorder,inorder,pl,pr,il,ir) {  
        if(pl > pr)
            return null;
        /* 找到根节点 */
        let m = arr.get(preorder[pl]);
        /* 获得在中序中 根节点左子树的中序遍历个数 */
        let l = m - il;
        const root = new TreeNode(preorder[pl]);
        root.left = f(preorder,inorder,pl + 1,pl + l,il,m - 1);
        root.right = f(preorder,inorder,pl + m + 1,pr,m + 1,ir);
        return root;
    }
    return f(preorder,inorder,0,preorder.length - 1,0,inorder.length - 1);
};
```

